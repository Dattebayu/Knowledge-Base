## Регулярные выражения

Регулярные выражения - определение какой-то закономерности вхождения подстроки в строку. Так же регулярные выражение регистра зависимы. Мы с начало описываем сам шаблон, по которому нужно делать поиск,а те данные, которые мы хотим найти обрамляем в `()`.

Так же есть возможность указать, что нам не интересно или наоборот. Допустим когда мы что то ищем, но есть какая вещь, которая нам не интересна или наоборот:

- `(?!page)` - будет искать все, но не page
- `(?=page)` - будет искать значение, которое равно page

Допустим у анс есть строка:

```php

$str = 'Masha iv   very beautifal';

```

Жадность квантификатора - изначально квантификатор жадный, что означает он берет всю строку до последнего совпадения. Допустим мы ищем любое количество символов больше 1, и потом ищем пробел, интерпретатор пройдет по всей строке и найдет самый последний пробел и выдаст всю строку и не будет смотреть на пробелы, которые внутри нее. Чтобы изменить поведение квантификатора перед выражением, свойство, которого мы хотим изменить нужно поставить знак `? `:

```php

preg_match('/.+?\s+/', $str, $matches);

```

`/.+?\s+/` - без знака вопроса данное регулярное выражение вернет всю строку `Masha iv very beautifal`, так как оно ищет самый конечный подходящий результат, ведя себя жадно. Но с ? она вернет только `Masha`, как первое совпадение.

Тоже самое можно задать и для глобального поиска all:

```php

preg_match_all('/.+\s+/U', $str, $matches);

```

Чтобы возвращалась не вся строка, а по очереди, используется специальный символ после `\` `U`.

Глобальные специальные символы(указываются после `/регулярное выражение/`):

- u - указывает на кодировку, чтобы можно было работать с мультибайтовой системой.
- U - понижает жадность квантификатора.
- i - указывает на то, что нам интересны и большие буквы и маленькие.
- m - для многострочного поиска.

Кроме обычных выражений в регулярных выражениях можно использовать так называемые переменные. Мы заключаем в скобки ту часть, которую хотим связать. Допустим нам нужно найти ссылку из обычно html документа и сама ссылка может быть обвернута в `'` или в `"` причем либо то, либо то, но не как не разные. Для этого мы делаем выражение `[\'"]`, которое означает, что мы выбираем или то, или то а потом заключаем это все в круглые скобки и чтобы обратиться к данной переменной мы используем `\номер` (номер это идентификатор на каком месте по счету стоят скобки, если их несколько, если у нас такая переменная 1, то пишем `\1` ):

```php

preg_match_all('/<a\s+[^>]*?href\s*=\s*([\'"])([^>}+?)"/', $str, $matches);

```

Регулярным выражением данной строки идет закономерность, которая говорит нам, что у нас есть слов и пробел, слово пробел и не важно количество пробелов, главное это суть закономерности, по которой работает наша строка.

Регулярное выражение обозначается в виде строки и заключен в ограничители, это могут быть любые символы, пример: `/ регулярное выражение /`, `# регулярное выражение #`, кроме тех, которые указываются в самом регулярном выражении.
Если в регулярном выражении нужно использовать `/`, то мы должны его экранировать, чтобы интерпретатор не разделил его с другим слешом, экранируется он с помощью обратного слеша `\`:

```php

'/\s//'

```

- Самый просто вид, который мы можем указать в регулярном выражении это обычная строка:

```php

preg_match('/str/', $str, $matches);

```

- Чтобы найти какие либо значения в строке, по типу букв, используются `[]`:

```php

preg_match('/[xy]/', $str, $matches);

```

- Существует возможность поиска в диапазоне:

```php

preg_match('/[a-c]/', $str, $matches);

```

- Поиск в диапазоне вмести с большими буквами:

```php

preg_match('/[a-zA-Z]/', $str, $matches);

```

- Кроме обычной записи регулярных выражений есть `специальные символы`, которые заменяют всю эту запись. Записываются они через обратный слешь(`/[\w]/`):

- w - `a-zA-Z0-9_`
- W обратная запись w, найдет все символы, которые не являются w
- d - все цифры
- D обратная запись
- n - перенос строки
- s - пробел, перенос строки
- S - обратная запись
- t - табуляция
- . - любой символ

- `Подмаска`, специальный модификатор к поиску, когда мы после значение указываем в скобках возможные варианты, которые нам подходят.
  В данном случаи нам нужно найти все совпадение, которые будут равняться `as` и `aпробел`:

```php

preg_match_all('/a(s|\s)/', $str, $matches);

```

В скобках мы написали, что нам подходит s, потом знак `|`, которые означает или и пробел через регулярное выражение `\s`.
Поиск подстроки в строке:

- Если нужно указать, какое-то определенное количество, которое нам интересно. Допустим нам нужно найти совпадение где идет 2 и более пробелов:

```php

preg_match_all('/\s{2,}\w/', $str, $matches);

```

`{2,}` - данная запись означает 2 и более.

- Так же можно ограничить количество символов, которые нам подходят:

```php

preg_match_all('/\s{2,4}\w/', $str, $matches);

```

`{2,4}` - данная запись означает, что нам подходит от 2 до 4 пробелов, идущих подряд.

- Существует краткая запись {1,}, которая записывается как `+`:

```php

preg_match_all('/\s+/', $str, $matches);

```

`/\s+/` - означает, что нам интересны все совпадения по пробелам и не важно сколько их, главное, что не 0.

- Существует краткая запись {0,}, которая записывается как `*`. Применяется тогда, когда нам интересна подстрока, которая будет и иметь данный символ/символы или не иметь:

```php

preg_match_all('/[\d]{3}\s*_/', $str, $matches);

```

`/[\d]{3}\s*_/` - нас будет удовлетворять записи `123_`, `123 _` и так далее, любой количество пробелов или их отсутствие между `123` и `_`

- Чтобы указать отрицание, если нам нужно найти не какой-то определенный символ, то в `[]`, которые означают символьная выборка, мы можешь использовать специальный символ `^`, который означает `не`:

```php

preg_match_all('/[^,f]\s{2,4}\w/', $str, $matches);

```

- Если указать `^` в начале регулярного выражения и вне квадратных скобок(символьного выражения), то оно будет искать совпадение по самому первому символу и не пойдет дальше:

```php

preg_match_all('/^[A-Z]/', $str, $matches);

```

- Так же есть символ конца строки `$`:

```php

preg_match_all('/[A-Z]$/', $str, $matches);

```

Поиск вхождений:

```php

preg_match('/str/', $str, $matches);

```

Данная функция имеет 3 аргумента:

- Первый, это регулярное выражение, по которому будет производиться поиск совпадение
- Второй, в какой строке
- Третий, сам найденный подтекст
  Изначально возвращает первое вхождение, без разницы в какой порядке они указаны в регулярном выражении.
  Для того чтобы искать все вхождения используется флаг all:

```php

preg_match_all('/str/', $str, $matches);

```
